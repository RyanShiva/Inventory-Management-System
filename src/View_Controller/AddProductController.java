package View_Controller;

import Model.*;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.stage.Stage;

import java.io.IOException;
import java.net.URL;
import java.util.Optional;
import java.util.ResourceBundle;

/** This class controls the AddProduct screen.
 *Logical Error description: The onActionAddPart event handler contained a logical error when it did not contain the if statement.
 When the user clicked the Add button, the handler did not check whether an item was selected in the addPartView before attempting to add the selected part to the associatedParts list.
 If a part was not selected in the top view, this would result in a null pointer being added to the associatedParts list.
 This pointer would appear as a blank row in the removePartView. It could be selected but not deleted.

 Error solution: The getSelectedItem() method will return null if a part is not selected in the Table View.
 I could tell that the null pointer was being added by the add() method to the associatedParts list by running the line of code:
 System.out.println(product.getAllAssociatedParts().size());
 at the end of the handler. The size of the list increased each time the Add button was clicked without a part selected.
 The error was fixed by using the if statement to check whether the getSelectedItem() method returned null.
 If null was returned, then a part was not selected and an error alert should be generated. Otherwise, the part will be added without a pop up message.
 */
public class AddProductController implements Initializable {

    Stage stage;
    Parent scene;

    Product product = new Product(FXCollections.observableArrayList(), 0, "", 0.00, 0, 0, 0);

    /** This method switches the screen to the location specified by the location parameter.
     * @param location path to the screen to load
     * @param event ActionEvent caused by the user clicking a button*/
    public void SwitchScreen (String location, ActionEvent event) throws IOException {
        stage = (Stage)((Button)event.getSource()).getScene().getWindow();
        scene = FXMLLoader.load(getClass().getResource(location));
        stage.setScene(new Scene(scene));
        stage.show();
    }

    /** This method generates a unique part ID.
     * @return unique part id integer*/
    public int generateId() {
        int greatestId = 0;
        for(Product product : Inventory.getAllProducts()) {
            if(product.getId() >= greatestId)
                greatestId = product.getId();
        }
        return ++greatestId;
    }

    @FXML
    private TextField maxTxt;

    @FXML
    private TextField minTxt;

    @FXML
    private TextField idTxt;

    @FXML
    private TextField nameTxt;

    @FXML
    private TextField invTxt;

    @FXML
    private TextField priceTxt;

    @FXML
    private TextField searchTxt;

    @FXML
    private TableView<Part> addPartView;

    @FXML
    private TableColumn<Part, Integer> addPartIdCol;

    @FXML
    private TableColumn<Part, String> addPartNameCol;

    @FXML
    private TableColumn<Part, Integer> addPartInventoryCol;

    @FXML
    private TableColumn<Part, Double> addPartPriceCol;

    @FXML
    private TableView<Part> removePartView;

    @FXML
    private TableColumn<Part, Integer> removePartIdCol;

    @FXML
    private TableColumn<Part, String> removePartNameCol;

    @FXML
    private TableColumn<Part, Integer> removePartInventoryCol;

    @FXML
    private TableColumn<Part, Double> removePartPriceCol;

    @FXML
    /** This is the onKeyPressedSearchParts event handler.
     * This method handles the event generated when the user searches for a part or clears the search bar.
     * @param event ActionEvent generated by the user searching for a part or clearing the search bar*/
    void onKeyPressedSearchParts(KeyEvent event) {
        if(searchTxt.getText().equals(""))
            addPartView.setItems(Inventory.getAllParts());
        else if(event.getCode().equals(KeyCode.ENTER)) {
            String query = searchTxt.getText();
            ObservableList<Part> matchingParts = Inventory.lookupPart(query);

            if (matchingParts.size() == 0) {
                try {
                    int id = Integer.parseInt(query);
                    if (Inventory.lookupPart(id) != null)
                        matchingParts.add(Inventory.lookupPart(id));
                } catch (NumberFormatException e) {
                    Alert alert = new Alert(Alert.AlertType.ERROR);
                    alert.setTitle("Error Dialog");
                    alert.setContentText("Part Name not found.");
                    alert.showAndWait();
                    return;
                }
            }
            if (matchingParts.size() != 0) {
                addPartView.setItems(matchingParts);
            } else {
                Alert alert = new Alert(Alert.AlertType.ERROR);
                alert.setTitle("Error Dialog");
                alert.setContentText("Part ID not found.");
                alert.showAndWait();
            }
        }
    }

    @FXML
    /** This is the onActionAddPart event handler.
     * When the Add button is clicked, the handler checks whether a part is selected and then adds the part to the temporary associated parts list.
     * @param event ActionEvent generated by the user clicking the Add button.*/
    void onActionAddPart(ActionEvent event) {
        if(addPartView.getSelectionModel().getSelectedItem() == null) {
            Alert alert2 = new Alert(Alert.AlertType.ERROR);
            alert2.setContentText("Please select a part to add.");
            alert2.showAndWait();
            return;
        }
        product.addAssociatedPart(addPartView.getSelectionModel().getSelectedItem());
    }

    @FXML
    /**This is the onActionDisplayMainScreen event handler. When the cancel button is clicked, this handler confirms the action and returns the user to the main screen.
     * @param event ActionEvent is generated when the user clicks the cancel button*/
    void onActionDisplayMainScreen(ActionEvent event) throws IOException {
        Alert alert = new Alert (Alert.AlertType.CONFIRMATION, "This will clear all text field values. Do you want to continue?");

        Optional<ButtonType> result = alert.showAndWait();

        if(result.isPresent() && result.get() == ButtonType.OK) {
            SwitchScreen("/View_Controller/Main Screen.fxml", event);
        }
    }


    @FXML
    /** This is the onActionRemovePart event handler.
     * When the Remove Associated Part button is clicked, the handler checks whether a part is selected and then deletes the part from the temporary associated parts list.
     * @param event ActionEvent generated by the user clicking the Remove Associated Part button.*/
    void onActionRemovePart(ActionEvent event) {
        if(removePartView.getSelectionModel().getSelectedItem() == null) {
            Alert alert2 = new Alert(Alert.AlertType.ERROR);
            alert2.setContentText("Please select a part to remove.");
            alert2.showAndWait();
            return;
        }

        Alert alert = new Alert (Alert.AlertType.CONFIRMATION, "Are you sure you want to remove this part?");

        Optional<ButtonType> result = alert.showAndWait();

        if(result.isPresent() && result.get() == ButtonType.OK) {
            product.deleteAssociatedPart(removePartView.getSelectionModel().getSelectedItem());
        }
    }

    @FXML
    /**This is the onActionSaveProduct event handler. When the Save button is clicked, this handler saves the product and switches to the main screen.
     * @param event ActionEvent is generated when the user clicks the Save button*/
    void onActionSaveProduct(ActionEvent event) throws IOException {
        try {
            int id = generateId();
            String name = nameTxt.getText();
            double price = Double.parseDouble(priceTxt.getText());
            int stock = Integer.parseInt(invTxt.getText());
            int min = Integer.parseInt(minTxt.getText());
            int max = Integer.parseInt(maxTxt.getText());

            if(min >= max) {
                Alert alert = new Alert (Alert.AlertType.ERROR);
                alert.setTitle("Error Dialog");
                alert.setContentText("Min must be less than Max!");
                alert.showAndWait();
                return;
            }
            if(stock < min || stock > max) {
                Alert alert = new Alert (Alert.AlertType.ERROR);
                alert.setTitle("Error Dialog");
                alert.setContentText("Inventory must be between Min and Max!");
                alert.showAndWait();
                return;
            }

            product.setId(id);
            product.setName(name);
            product.setPrice(price);
            product.setStock(stock);
            product.setMin(min);
            product.setMax(max);

            Inventory.addProduct(product);

            SwitchScreen("/View_Controller/Main Screen.fxml", event);
        }
        catch (NumberFormatException e) {
            Alert alert = new Alert (Alert.AlertType.ERROR);
            alert.setTitle("Error Dialog");
            alert.setContentText("Please enter a valid value for each text field.");
            alert.showAndWait();
        }
    }

    @Override
    /**This is the initialize method. This method initializes the controller.
     * @param rb
     * @param url*/
    public void initialize(URL url, ResourceBundle rb) {
        addPartView.setItems(Inventory.getAllParts());
        addPartIdCol.setCellValueFactory(new PropertyValueFactory<>("id"));
        addPartNameCol.setCellValueFactory(new PropertyValueFactory<>("name"));
        addPartInventoryCol.setCellValueFactory(new PropertyValueFactory<>("stock"));
        addPartPriceCol.setCellValueFactory(new PropertyValueFactory<>("price"));

        removePartView.setItems(product.getAllAssociatedParts());
        removePartIdCol.setCellValueFactory(new PropertyValueFactory<>("id"));
        removePartNameCol.setCellValueFactory(new PropertyValueFactory<>("name"));
        removePartInventoryCol.setCellValueFactory(new PropertyValueFactory<>("stock"));
        removePartPriceCol.setCellValueFactory(new PropertyValueFactory<>("price"));
    }

}
